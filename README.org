* hackery to make calibre's viewer show (not make) annotations
  
** motivation

   read epub on mobile device, that supports annotation, such as Kindle or Mantano.

   You get the annotations from that program, but want to see them in context back on your Calibre machine.

   Presumably you downloaded your annotations in some loose text-like form.

   You can also create your own annotations by hand.

** development

   currently lauching the program this way:

   #+begin_src sh :eval never
     CALIBRE_DEVELOP_FROM=../calibre-src/src calibre-debug -w path-to.epub
   #+end_src

** 2013-02-19

   succeeded in conjuring up the QWebInspector window from the document viewer, as well as execute arbitrary javascript

   =waitok()= is a poor man's blocking function to check where we are... i =touch /tmp/okgo= to resume execution. this is because =raw_input()= started throwing exceptions once you get too deep into the Qt app's control (my guess). Thankfully didn't use this too much.

=== modified file 'src/calibre/gui2/viewer/documentview.py'
--- src/calibre/gui2/viewer/documentview.py	2013-02-18 07:24:55 +0000
+++ src/calibre/gui2/viewer/documentview.py	2013-02-20 03:17:49 +0000
@@ -5,6 +5,16 @@
 
 # Imports {{{
 import os, math, json
+import time
+def waitok(msg = ""): # poor man's blocker
+    okgo_filepath = "/tmp/okgo"
+    mycount = 0
+    while not os.path.exists(okgo_filepath):
+        mycount += 1
+        print("waiting for okgo %s %s" % (msg, mycount))
+        time.sleep(1)
+    os.unlink(okgo_filepath)
+
 from base64 import b64encode
 from functools import partial
 
@@ -13,6 +23,7 @@
         QIcon, pyqtSignature, QAction, QMenu, QString, pyqtSignal,
         QSwipeGesture, QApplication, pyqtSlot)
 from PyQt4.QtWebKit import QWebPage, QWebView, QWebSettings, QWebElement
+from PyQt4.QtWebKit import QWebInspector
 
 from calibre.gui2.viewer.flip import SlideFlip
 from calibre.gui2.shortcuts import Shortcuts
@@ -551,6 +562,10 @@
         self.restore_fonts_action.setCheckable(True)
         self.restore_fonts_action.triggered.connect(self.restore_font_size)
 
+        # self.settings().setAttribute(
+        #     QWebSettings.WebAttribute.DeveloperExtrasEnabled, True)
+        self.inspect = QWebInspector()
+
     def goto_next_section(self, *args):
         if self.manager is not None:
             self.manager.goto_next_section()
@@ -851,6 +866,11 @@
             else:
                 self.flipper(self.current_page_image(),
                         duration=self.document.page_flip_duration)
+        print "EVALING JS"
+        js = "for(var lsp = document.getElementsByTagName('p'), i = 0; i < lsp.length; ++i) { lsp[i].innerHTML = '<span style=\"background-color: green;\">' + lsp[i].innerHTML + '</span>'; };"
+        self.page().mainFrame().evaluateJavaScript(js)
+        self.inspect.setPage(self.page())
+        self.inspect.show()
 
     @classmethod
     def test_line(cls, img, y):

** 2013-02-22

   Here is an example note entry that was loosely converted to orgmode:

#+begin_example
: ,* Title: Listing 8.1. An impl... (p.187)
: 
: Highlighted text
: ......................................
: Listing 8.1. An implementation of eval taking a local context
: ......................................
: 
: [2012-11-29 12:03]
: 
: - - - - - - - - - - - - - - - - - - - - - - - - - -
: 
: 
#+end_example

   The page number is from Mantano, which is probably matched up with the reader, factoring its current viewing size (i.e. it changes all the time), and gets outputted as-is on export. IOW, aside of telling us about relative order, is mostly useless unless we figure out the page number mapping to ebook location in calibre's viewer. Not worth the time.

   convert that to yaml:

#+begin_example
  - lookup: Listing 8.1. An impl... (p.187)
    highlight: |
      Listing 8.1. An implementation of eval taking a local context
    time: 2012-11-29 12:03
  
#+end_example
   
   =pip install epub=

   read it with this script to test:

#+begin_src python :eval never
  import yaml
  import epub
  import re
  
  book = epub.open_epub("test.epub")
  
  lsnote = yaml.load(open("note.yml"))
  
  mydc = dict((key, book.read_item(item)) for key, item in filter(lambda (k, i): k.startswith("html"), book.opf.manifest.items()))
      
  for key in sorted(mydc.keys(), lambda a, b: int(a[4:]) > int(b[4:]) and 1 or -1):
      xml = mydc[key]
      nidx = 0
      while nidx < len(lsnote):
          note = lsnote[nidx]
          lookup = note['lookup'].split('...', 1)[0]
          if lookup in re.sub('<[^>]*>', '', xml).replace('\n', ''):
              print "FOUND", key
              del lsnote[nidx]
          else:
              nidx += 1
  
#+end_src

#+RESULTS:
: FOUND html13
: FOUND html22
: FOUND html22
: FOUND html22

now we know we can locate the lookup (assuming all highlights are long enough).

next is to coerce calibre's viewers to change its markup at the right places

*** Manning epubs

    it turns out the example book here, Fogus's /The Joy of Clojure/, has a bunch of calibre markup in it: looks like Manning is running a calibre converter in the backend?

** 2013-02-23

*** adding manhole

    following =CalibrePluginScaleATon= to inject a manhole

    for emacs, change the telnet prompt regexp to make interaction easier:

    #+begin_src emacs-lisp
    ;; default: (defvar telnet-prompt-pattern "^[^#$%>\n]*[#$%>] *")
    (setq telnet-prompt-pattern "^>>> *")
    #+end_src

*** jack into =DocumentView.load_finished=

    we're looking for location information that corresponds to nth file
    as obtained from the test.epub/note.yml matchup
    
    #+begin_example
      >>> see(self)
          .*                      hash()                  repr()
          str()                   .DISABLED_BRUSH         .DrawChildren
          .DrawWindowBackground   .IgnoreMask             .PaintDeviceMetric()
          .PdmDepth               .PdmDpiX                .PdmDpiY
          .PdmHeight              .PdmHeightMM            .PdmNumColors
          ...
          ...
          ...
          .windowRole()           .windowState()          .windowTitle()
          .windowType()           .x()                    .x11Info()
          .x11PictureHandle()     .y()                    .zoomFactor()
      >>> self.page.__doc__
      'QWebView.page() -> QWebPage'
      >>> print(self.page().mainFrame().toHtml()[:200])
      <!--?xml version='1.0' encoding='utf-8'?--><html xmlns:mbp="Kindle" xmlns="http://www.w3.org/1999/xhtml"><head>
          <title>The Joy of Clojure: Thinking the Clojure Way</title>
          <meta content="http:
      
    #+end_example

*** =src/calibre/gui2/viewer/main.py=

    this is where the =EbookViewer= class and the =DocumentView='s =manager= is defined

*** calibre's epub caching + rendering

    so calibre's ebook viewer uses a calibre library (I think) that writes html files to a temp directory

    where each html corresponds to a major section, which calibre paginates in smaller pieces while reading. When a file boundary is crossed (probably always the case in changing chapters), the corresponding file is loaded; crossing these boundaries calls =EbookViewer.next_document= and =EbookViewer.previous_document=, which calls =DocumentView.load_path=, which calls =calibre.ebooks.oeb.display.webview.load_html=

*** matching up with =epub= manifest (not going to work?)

    the total number of html files in that directory matches the total retrieved by the =epub= library,
    but the labeling order doesn't match up: in this example, calibre's extraction looks like =kindle_split_012.html=
    but the content corresponding to =epub='s =html12= key resides in a different file.

    so to be quick and dirty we'll just build up a cache of all the notes, and search through the full text
    of the currently viewed page

*** calibre.ebooks.oeb.display.webview

    =load_html= function is where the epub's html gets extracted and set


** 2013-02-24

   opting for a naive but a hack that works for at least 3 test notes on at least 1 test book:
   
   [[./doc/img/ss-001.png]]

   The grunt work is in =AnnotationProcessor.py= and is untested hackery. Basically, after calibre's viewer (=calibre/gui2/viewer/documentview.py=) calls =load_html=, we grab that value and send it the Processor and re-set it. The processor:

   1. removes all extra whitespace, perserving newlines (important because there are =<pre>= blocks), call this the =cleanstring=-ed html
   2. we locate start and end indexes for non-tag elements
   3. create a temporary "fulltext" from concatenating all non-tag elements
   4. match this against the notes lookup (again, assume all are long enough and copy-pasted extractions) and locate indexes from matches
   5. surround matched strings with highlight tags (=tagged= template)
   6. using the non-tag start and end indexes, grab the tags by substring and reconstruct the html
   7. re-run =self.setHTML= on the processed html
      
   So the important lines in =calibre/gui2/viewer/documentview.py= are:

   #+begin_src python :eval never
     # at top
     import AnnotationProcessor
     
     # ...
     # ...
     # ...
     
     def load_path(self, path, pos=0.0):
         self.initial_pos = pos
         self.last_loaded_path = path
     
         def callback(lu):
             self.loading_url = lu
             if self.manager is not None:
                 self.manager.load_started()
     
         load_html(path, self, codec=getattr(path, 'encoding', 'utf-8'), mime_type=getattr(path,
             'mime_type', 'text/html'), pre_load_callback=callback,
                   force_as_html=True)
     
         # intercept + hack in our highlights
         myhtml = self.page().mainFrame().toHtml()
         newhtml = AnnotationProcessor.process_html(AnnotationProcessor.note, str(myhtml).decode("utf-8"))
         self.setHtml(newhtml, self.page().mainFrame().url())
     
         # the rest as usual
         
         entries = set()
         for ie in getattr(path, 'index_entries', []):
             if ie.start_anchor:
                 entries.add(ie.start_anchor)
             if ie.end_anchor:
                 entries.add(ie.end_anchor)
         self.document.index_anchors = entries
     
         # ...
   #+end_src

   =AnnotationProcessor.py= expects you have a =note.yml= file sitting in its path. Next steps are to make that more intelligent.

   
   
