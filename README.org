#+ARCHIVE: doc/devlog/%s_archive::

* adding annotation (read and write) capability to calibre's ebook-viewer
  
  sporadic work in progress. last updated on 2016-02-10 *(BREAKS
  EARLIER VERSION, see below)*

  *WARNING: if you have used this before, and are planning to update,
  please backup your highlights database before updating*

  this plugin is *NOT* pre-packaged and ready to use. You will need to
  setup some dependencies (see below)

  [[./doc/img/ss-007.png]]
  
  There are 2 main issues we care about here, addressed in headings below

  1. importing, i.e. reading annotations made elsewhere.
  2. editing, i.e. displaying and editing annotations in calibre's
     =ebook-viewer= program. this is doable now. read below for
     details. notes are stored into an =sqlite= database using the
     =okfn/annotator= API and thus their JSON format.

* external dependencies + preparation

  - =sqlalchemy= (currently working with =0.9.8=)
    
  installable via =pip install sqlalchemy=; due to *PATH HACK* below,
  we're assuming a system install where you know the inclusion path
  for both libraries

** alternative installation

   [[http://www.sqlalchemy.org/download.html][download]] and extract sqlalchemy, and

   =mv SQLAlchemy-*/lib/sqlalchemy calibre/lib/python2.7/site-packages=

* installing+using the plugin

  *NOTE: if you have problems installing over an existing =Viewer Annotation Plugin.zip= in your calibre plugins directory, try deleting that zip file first*

  1. ensure you have a working development environment set up (basically, ensure you can run =calibre-customize=)
  2. clone this repo
  3. edit the *PATH HACK* [[file:ViewerAnnotationPlugin/annotator_model.py]]
     so calibre is able to see your local install of =sqlalchemy=.  It is
     currently hard-coded to search in
     =/usr/local/lib/python2.7/dist-packages=. There's probably a way to make
     this self-contained; see discussion [[http://www.mobileread.com/forums/showthread.php?t%3D241076][here]] but it's not currently a priority.
  4. in your terminal/command line program, navigate to the
     =ViewerAnnotationPlugin= directory and run =calibre-customize -b .=
     to install the plugin. If successful your =ebook-viewer= should
     incorporate the annotations. By default it will create a sqlite
     database =ebook-viewer-annotation.db= into your home directory.
     
* importing annotations
  
  as of now, this is a harder problem. my next investigation in this
  area will follow things discussed below like in
  =AnnotationProcessor.py= and =anchortext.py=
  
** USAGE (update 2016-03-01)

   prelim importer logic. very hacky.

   The general process is encapsulated and described in the =import_utility.rb= script. It relies on these components:
   
*** generate highlights yml files

    for kindle, this uses =get_kindle_highlights.rb=, it relies on
    [[https://github.com/speric/kindle-highlights][speric's kindle-highlights]] so you will need to run =gem install
    kindle-highlights=. You can either enter your login information
    at run-time, or store your login information in a file at
    =~/.aws/kindle= or =~/.aws/kindle.gpg= if you have the =gpgme=
    gem installed.
    
    this script and does some additional matching and sanity checking
    on top of =kindle-highlights=. *In particular, speric's version
    does not handle text notes attached to highlights*; this script
    does a 2-pass to put them together.

*** reconcile annotation positions with =nw-extractor=

    what it does: displays externally stored (in e.g. yml files)
    annotations, tries to locate the annotations within a given epub
    file, and derives calibre-compatible =xpath= entities to export

**** npm-installed dependencies

     - nw (node webkit)
     - glob, html-entities, js-yaml, xpath-range
     - browserify (needed for xpath-range)
     - epub
     - striptags

**** how to use it

     basically check if the left column (external notes) matches the
     text in the right column (inside ebook). Green = good match,
     where yellow is worse and red is probably fail.

     At the bottom is a "RECONCILE ALL" button, which will attempt to
     create an importable json file containing the notes with =xpath=
     addresses attached to them.

**** how xpath derivation works
     
     parent window opens a child window that loads the corresponding
     ebook chapter file, and searches for the best matching string,
     then derives the xpath-range via the =doMagic= logic (see below),
     and returns it to the parent process.

     this method is very ugly (uses setTimer because it doesn't know
     when the child window is finished loading). If you know a fix
     please let me know!

**** check the highlights + click the =test= button to see if it works

     then scroll to the bottom and click the =reconcile= button and hope it works for everything

*** import the output json and write to the ebook-viewer-annotation database

    =python importjson.py xpath-matched-output.json ebook-file.epub=

    will perform a dry run, and you can check for surprises. the ebook
    file is optional. It is used to generate =anchor= entries, but the
    anchor positioning logic is not yet implemented (so we are relying
    on the =xpath= being accurate and robust).

    this will output basic information of what matches and what fails.
    if you are lucky, everything will find its proper position.

    once everything looks ok, apply the changes with
   
    =DRY_RUN=FALSE python importjson.py xpath-matched-output.json ebook-file.epub=

* development
  
  The base plugin code is loosely taken from [[http://manual.calibre-ebook.com/creating_plugins.html#a-user-interface-plugin][user interface plugin]],
  although the viewer plugin is slightly different. refer to the
  [[http://manual.calibre-ebook.com/plugins.html#viewer-plugins][Viewer plugins]] section in the calibre API documentation. Other
  exploratory notes on interacting with calibre proper may be found in
  the =doc/devlog=.
  
  To play with this code, edit the code in the =ViewerAnnotationPlugin=
  directory, then run

  #+BEGIN_SRC sh :eval never
    calibre-customize -b . && ebook-viewer $PATH_TO_EPUB
  #+END_SRC
  
  and it should launch the viewer with the changes applied.

** building source files

*** build xpath-range =doMagic= function

    copy paste from https://github.com/openannotation/xpath-range, BUT you want the range *returned*, so:

    #+BEGIN_SRC javascript :eval never
      Range = require("xpath-range").Range;
      
      doMagic = function() {
        range    = getSelection().getRangeAt(0);
        bRange = new Range.BrowserRange(range);
        sRange = bRange.serialize(document.body);
        console.log(sRange);
        return sRange;
      }
      
    #+END_SRC

    save as =xpath-range.js= (we're now in =nw-extractor/node_modules/xpath-range=)

    then run =browserify xpath-range.js -o xpath-range-bundle.js=

*** compile =cfi.coffee= from calibre

    =coffee --compile cfi.coffee=

    this is what's inside =driver.js=

*** =driver.js=

    with current method, we're delegating html range finding to a spawned child window.
    since we don't want to alter the dom, we use node-webkit's =inject-js-start= and =inject-js-end=
    to send it the functions we want. so =driver.js= must contain all the range finder code.

    then append =cfi.js= into =driver.js=

** data model
   
   *TODO: describe anchor model* (currently not used in viewer / annotator.js)
   
   We generally follow the [[http://docs.annotatorjs.org/en/v1.2.x/annotation-format.html][format from Annotator]]

   A sample =Annotation= structure is like:
   
   #+BEGIN_SRC javascript :eval never
     {
       "id": 42,                                  // INTEGER NOT NULL PRIMARY KEY
       "created": "2014-11-02 12:19:13.000000",   // DATETIME DEFAULT NOW
       "updated": "2014-11-02 12:19:13.000000",   // DATETIME DEFAULT NOW
       
       "title": "The title of an exemplary book", // TEXT, title of book in Calibre
       "text": "A note I wrote",                  // TEXT, content of annotation
       "quote": "The text actually said this, since I quoted it.", // TEXT, the annotated text (added by frontend)
       "uri": "epub://part0036.html",             // TEXT, URI of annotated document (added by frontend)

       "user": "yousir",
       
       // these are populated run-time by backref via the `range` table
       "ranges": [                                // list of ranges covered by annotation (usually only one entry)
         {
           "start": "/p[69]/span/span",           // (relative) XPath to start element
           "end": "/p[70]/span/span",             // (relative) XPath to end element
           "startOffset": 23,                     // character offset within start element
           "endOffset": 120                       // character offset within end element
         }
       ]
     }
   #+END_SRC
  
   A sample =Range= structure is like:

   #+BEGIN_SRC javascript :eval never
     {
       "id": 2,                               // INTEGER NOT NULL PRIMARY KEY
       "start": "/p[69]/span/span",           // VARCHAR(255), (relative) XPath to start element
       "end": "/p[70]/span/span",             // VARCHAR(255), (relative) XPath to end element
       "startOffset": 23,                     // INTEGER, character offset within start element
       "endOffset": 120,                      // INTEGER, character offset within end element
       
       "annotation_id": 42                    // INTEGER FOREIGN KEY(annotation.id)
     }


   #+END_SRC

   The =Consumer= model is defined (inherited from the older reference
   implementation) but is not used.

** okfn/annotator files

   current code is hard-coded to expect =annotator-full.1.2.7=
   for javascript/css. For a different version:

   1. visit https://github.com/okfn/annotator/downloads/
   2. if you've unzipped e.g. annotator-full.1.2.7.zip, you should get
      a directory =annotator-full.1.2.7/= with a =.js= and a =.css= file
      inside it. Move this directory into the =ViewerAnnotationPlugin=
      directory.
   3. edit =ViewerAnnotationPlugin/__init__.py= and find the
      =load_javascript= and =run_javascript= sections and make sure the
      paths there correspond to your extracted annotator js/css
      files.

** okfn/annotator plugin (store.js)

   see =store.coffee=; =store.js= is derived from =coffee --compile store.coffee=
   then moved into =ViewerAnnotationPlugin=

* breaking changes / updating / migrating

  The most recent update (2016-02) is not compatible with all updates
  prior to 2016. However, the data model is mostly the same.
  
*** TOFIX

    - sometimes editing an annotation raises a UnicodeError (could be related to imported highlights)
    - annotation stops working with changing flow mode (ref https://github.com/whacked/calibre-viewer-annotation/issues/2)


*** 2016-02-09 :: elixir removed, change model;
    
    If you actually need to migrate, see [[file:migrate.sh]] which tries
    to convert the tables to the newer data model.

    In particular, =quote= is now the default =Annotation= field to
    store the highlighted text; =text= is for comments. =timestamp= is
    superceded by =updated= and =created=.
  
* issues

  - either the js file inclusion or css style injection or both cause
    long pauses in the reader when navigating between epub chapter
    boundaries


  
